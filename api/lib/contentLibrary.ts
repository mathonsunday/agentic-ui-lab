/**
 * Content Library: Hardcoded Production Features
 *
 * This service explicitly catalogs all hardcoded content features in the system.
 * Rather than hiding feature logic in conditionals, this makes it clear that these
 * are intentional production features with curated contentâ€”not tests or experiments.
 *
 * Design philosophy:
 * - Content features are first-class citizens, not hidden implementation details
 * - Each feature has clear metadata about its purpose and implementation
 * - Discovery is straightforward: look at this file to see all hardcoded features
 * - Extensibility: adding new content features follows a clear pattern
 *
 * This helps both human developers and AI agents understand the codebase:
 * - No mysterious conditionals in analyze-user-stream.ts
 * - Clear intent: these are intentional product features, not hacks
 * - Centralized content management: changes to text happen in one place
 */

import { SPECIMEN_47_GRANT_PROPOSAL } from './responseLibrary';

export interface ContentFeature {
  /** Unique identifier for this content feature */
  id: string;

  /** Display name */
  name: string;

  /** Detailed description of what this feature does */
  description: string;

  /** The content text to stream to the user */
  content: string;

  /** User input patterns that trigger this feature (case-insensitive substring match) */
  triggers: string[];

  /** Source identifier sent in TEXT_MESSAGE_START event (for frontend handling) */
  eventSource: string;

  /** Confidence delta applied when this feature is triggered */
  confidenceDelta: number;

  /** Whether this content is hardcoded (vs. generated by Claude) */
  isHardcoded: true;

  /** Purpose and rationale for this feature */
  purpose: string;

  /** Status in product lifecycle: 'production', 'experimental', or 'deprecated' */
  status: 'production' | 'experimental' | 'deprecated';
}

/**
 * Central registry of all content features
 *
 * When users trigger certain input patterns, the system delivers curated content
 * instead of routing to Claude. This allows for consistent, high-quality responses
 * on specific topics while keeping the core Claude analysis path clean.
 */
export const ContentLibrary: Record<string, ContentFeature> = {
  SPECIMEN_47: {
    id: 'specimen_47',
    name: 'Specimen 47 - Deep Sea Research Proposal',
    description:
      'A hardcoded research grant proposal about a bioluminescent organism discovered at hadal depths. ' +
      'Used as a core product feature to showcase streaming, interruption, and character-by-character animation.',
    content: SPECIMEN_47_GRANT_PROPOSAL,
    triggers: ['specimen 47', 'specimen47', 'grant'],
    eventSource: 'specimen_47',
    confidenceDelta: 8,
    isHardcoded: true,
    purpose:
      'Deliver a consistent, high-quality narrative experience that demonstrates the streaming UI capabilities. ' +
      'The proposal is thematically connected to Mira (deep-sea exploration, scientific discovery) and serves ' +
      'as both a product feature and a technical showcase of character-by-character animation with streaming content.',
    status: 'production',
  },
};

/**
 * Check if user input should trigger a content feature
 * Returns the matching feature or null if no match
 *
 * This is the single point where input routing happens:
 * - First check if this is a hardcoded content feature
 * - If not, continue to Claude analysis
 *
 * @param userInput The raw user input
 * @returns The matching ContentFeature or null
 */
export function getContentFeature(userInput: string): ContentFeature | null {
  if (!userInput) return null;

  const lowerInput = userInput.toLowerCase();

  for (const feature of Object.values(ContentLibrary)) {
    // Check if any trigger matches (substring match, case-insensitive)
    if (feature.triggers.some(trigger => lowerInput.includes(trigger))) {
      return feature;
    }
  }

  return null;
}

/**
 * List all available content features
 * Useful for documentation, admin panels, or debugging
 */
export function listContentFeatures(): ContentFeature[] {
  return Object.values(ContentLibrary);
}

/**
 * Get a specific content feature by ID
 */
export function getContentFeatureById(id: string): ContentFeature | null {
  return Object.values(ContentLibrary).find(f => f.id === id) || null;
}
